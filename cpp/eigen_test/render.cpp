/*
 * Copyright (C) 2020 zach zachary.neveu@gmail.com
 */

#include <Bela.h>
#include <Eigen/Dense>
#include <iostream>
#include <random>
#include "utils.h"
#include "FIR.h"
#include "IIR.h"
#include <libraries/ADSR/ADSR.h>
#include <libraries/Scope/Scope.h>

using namespace Eigen;
using namespace std;

#define NTAPS 128
#define NAS 3
#define NBS 2

MatrixXf Taps(NTAPS,1);
MatrixXd DTaps(NTAPS,1);
MatrixXf ATaps(NAS,1); 
MatrixXf BTaps(NBS,1);

FIR fir(NTAPS);
IIR iir(2,3);
Scope sc;

// Return true if all goes well
bool setup(BelaContext *context, void *userData)
{
	DTaps << 
0.0030312512441025468,
-0.0014428802916218626,
-0.0013573460862380173,
-0.0014027316529828511,
-0.0015447886489307738,
-0.0017606235635688559,
-0.002032732586904482,
-0.002348813025758271,
-0.002700982295993403,
-0.00308282031089098,
-0.003487615305540369,
-0.003908895515142552,
-0.0043411227854469655,
-0.004779019427479735,
-0.0052165034272761805,
-0.005646640525823413,
-0.006062341635354035,
-0.0064566553461263025,
-0.0068224415392713345,
-0.007152143940289638,
-0.007438000329823851,
-0.007672286981473158,
-0.007847297317144957,
-0.00795530905745033,
-0.007988808193580057,
-0.007940791663966358,
-0.007804854930010161,
-0.007575115939824546,
-0.007246238346490436,
-0.006813617697971383,
-0.006273556995102656,
-0.005623314890871554,
-0.0048611073119872415,
-0.003986185817855783,
-0.0029989832140842,
-0.001901206696644239,
-0.00069580895931396,
0.0006130856042456443,
0.0020201757088526098,
0.0035189165382196446,
0.005101542860510486,
0.006759218715074535,
0.00848213511274606,
0.010259452518770081,
0.012079300497686385,
0.013929048752596084,
0.015795624858541406,
0.017665484874312288,
0.01952437636172505,
0.021357481518398138,
0.02315002268813855,
0.024887645141825315,
0.02655622756714725,
0.028141813778256593,
0.029631225850746505,
0.031012491931575997,
0.03227400469095049,
0.03340344470336452,
0.03438886719467992,
0.03522177793354054,
0.03589814948403599,
0.03641422128975149,
0.03675979191130803,
0.03692949266695883,
0.03692949266695883,
0.03675979191130803,
0.03641422128975149,
0.03589814948403599,
0.03522177793354054,
0.03438886719467992,
0.03340344470336452,
0.03227400469095049,
0.031012491931575997,
0.029631225850746505,
0.028141813778256593,
0.02655622756714725,
0.024887645141825315,
0.02315002268813855,
0.021357481518398138,
0.01952437636172505,
0.017665484874312288,
0.015795624858541406,
0.013929048752596084,
0.012079300497686385,
0.010259452518770081,
0.00848213511274606,
0.006759218715074535,
0.005101542860510486,
0.0035189165382196446,
0.0020201757088526098,
0.0006130856042456443,
-0.00069580895931396,
-0.001901206696644239,
-0.0029989832140842,
-0.003986185817855783,
-0.0048611073119872415,
-0.005623314890871554,
-0.006273556995102656,
-0.006813617697971383,
-0.007246238346490436,
-0.007575115939824546,
-0.007804854930010161,
-0.007940791663966358,
-0.007988808193580057,
-0.00795530905745033,
-0.007847297317144957,
-0.007672286981473158,
-0.007438000329823851,
-0.007152143940289638,
-0.0068224415392713345,
-0.0064566553461263025,
-0.006062341635354035,
-0.005646640525823413,
-0.0052165034272761805,
-0.004779019427479735,
-0.0043411227854469655,
-0.003908895515142552,
-0.003487615305540369,
-0.00308282031089098,
-0.002700982295993403,
-0.002348813025758271,
-0.002032732586904482,
-0.0017606235635688559,
-0.0015447886489307738,
-0.0014027316529828511,
-0.0013573460862380173,
-0.0014428802916218626,
0.0030312512441025468;


	ATaps <<  0.0045278027526511775,
	0.009055605505302355,
	0.0045278027526511775;

	BTaps << -1.769321540687475,
	0.7874327516980797;

	Taps = DTaps.cast <float> ();

	Taps.normalize();
	fir.setTaps(Taps);
	ATaps.normalize();
	BTaps.normalize();
	iir.setTaps(ATaps, BTaps);

	sc.setup(2, context->audioSampleRate);

	//cout << "Taps: " << endl << Taps << endl;

	return true;
}

// Triggered by audio interface interrupt
void render(BelaContext *context, void *userData)
{
	float new_samp, fir_out_samp, iir_out_samp;
	for (size_t i = 0; i < context->audioFrames; i++)
	{
		new_samp = audioRead(context, i, 0);
		fir_out_samp = fir.process(new_samp);
		iir_out_samp = iir.process(new_samp);

		audioWrite(context, i, 0, fir_out_samp);
		audioWrite(context, i, 1, iir_out_samp);
		sc.log(fir_out_samp, iir_out_samp);
	}
}


void cleanup(BelaContext *context, void *userData)
{

}
